"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var use_async_1 = require("@nutgaard/use-async");
var react_1 = require("react");
var fetch_cache_1 = require("./fetch-cache");
var fetch_cache_2 = require("./fetch-cache");
exports.cache = fetch_cache_2.default;
__export(require("@nutgaard/use-async"));
function createCacheKey(url, option) {
    var method = (option && option.method) || 'GET';
    var body = (option && option.body && option.body.toString()) || '';
    var headers = (option && option.headers && JSON.stringify(option.headers)) || '';
    return [url, method.toUpperCase(), body, headers].join('||');
}
exports.createCacheKey = createCacheKey;
function handleResponse(response, setStatusCode, cacheKey) {
    return response
        .then(function (resp) {
        setStatusCode(resp.status);
        if (!resp.ok) {
            throw new Error(resp.statusText);
        }
        if ([200, 201, 203, 206].includes(resp.status)) {
            return resp.json();
        }
        return;
    })
        .then(function (json) {
        fetch_cache_1.default.putResolved(cacheKey, json);
        return json;
    });
}
function useFetch(url, option, config) {
    if (config === void 0) { config = {
        lazy: false,
        cacheKey: undefined
    }; }
    var _a = react_1.useState(-1), statusCode = _a[0], setStatusCode = _a[1];
    var defaultCacheKey = createCacheKey(url, option);
    var cacheKey = config.cacheKey || defaultCacheKey;
    var source = react_1.useCallback(function (isRerun) {
        setStatusCode(-1);
        var response = isRerun ? fetch(url, option) : fetch_cache_1.default.fetch(cacheKey, url, option);
        if (isRerun) {
            fetch_cache_1.default.put(cacheKey, response);
        }
        return handleResponse(response, setStatusCode, cacheKey);
    }, [url, option, cacheKey]);
    var initialConfig = fetch_cache_1.default.hasKeyResolved(cacheKey)
        ? { status: use_async_1.Status.OK, data: fetch_cache_1.default.getResolved(cacheKey) }
        : undefined;
    var asyncResult = use_async_1.default(source, config.lazy, [source], initialConfig);
    return react_1.useMemo(function () {
        return __assign({}, asyncResult, { statusCode: statusCode });
    }, [asyncResult, statusCode]);
}
exports.default = useFetch;
//# sourceMappingURL=use-fetch.js.map