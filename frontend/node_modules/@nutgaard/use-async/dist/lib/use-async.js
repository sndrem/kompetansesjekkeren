"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var Status;
(function (Status) {
    Status["INIT"] = "INIT";
    Status["PENDING"] = "PENDING";
    Status["OK"] = "OK";
    Status["ERROR"] = "ERROR";
    Status["RELOADING"] = "RELOADING";
})(Status = exports.Status || (exports.Status = {}));
function isPending(result) {
    return [Status.INIT, Status.PENDING].includes(result.status);
}
exports.isPending = isPending;
function hasData(result) {
    return [Status.OK, Status.RELOADING].includes(result.status);
}
exports.hasData = hasData;
function hasError(result) {
    return result.status === Status.ERROR;
}
exports.hasError = hasError;
function useAsync(source, lazy, dependencyList, initialState) {
    if (lazy === void 0) { lazy = false; }
    var isCancelled = react_1.useRef(false);
    var _a = react_1.useState(0), rerunValue = _a[0], setRerunValue = _a[1];
    var lastRerun = react_1.useRef(rerunValue);
    var _b = react_1.useState(initialState || {
        status: lazy ? Status.INIT : Status.PENDING
    }), state = _b[0], setState = _b[1];
    react_1.useEffect(function () {
        var isRerun = lastRerun.current !== rerunValue;
        lastRerun.current = rerunValue;
        if (!lazy || (isRerun && ![Status.PENDING, Status.RELOADING].includes(state.status))) {
            if (state.status === Status.OK) {
                setState({ status: Status.RELOADING, data: state.data });
            }
            else {
                setState({ status: Status.PENDING });
            }
            source(isRerun).then(function (data) {
                if (!isCancelled.current) {
                    setState({ status: Status.OK, data: data });
                }
            }, function (error) {
                console.error(error);
                if (!isCancelled.current) {
                    setState({ status: Status.ERROR, error: error });
                }
            });
        }
        // Alle skal være med, men eslint greier ikke å analysere den
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencyList
        ? dependencyList.concat([rerunValue, lazy, isCancelled]) : [source, rerunValue, lazy, isCancelled]);
    react_1.useEffect(function () {
        return function () {
            isCancelled.current = true;
        };
    }, [isCancelled]);
    var rerun = react_1.useCallback(function () {
        setRerunValue(function (v) { return v + 1; });
    }, []);
    return react_1.useMemo(function () { return (__assign({}, state, { rerun: rerun })); }, [state, rerun]);
}
exports.default = useAsync;
//# sourceMappingURL=use-async.js.map