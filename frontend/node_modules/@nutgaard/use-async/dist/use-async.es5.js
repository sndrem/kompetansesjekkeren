import { useCallback, useEffect, useMemo, useRef, useState } from 'react';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var Status;
(function (Status) {
    Status["INIT"] = "INIT";
    Status["PENDING"] = "PENDING";
    Status["OK"] = "OK";
    Status["ERROR"] = "ERROR";
    Status["RELOADING"] = "RELOADING";
})(Status || (Status = {}));
function isPending(result) {
    return [Status.INIT, Status.PENDING].includes(result.status);
}
function hasData(result) {
    return [Status.OK, Status.RELOADING].includes(result.status);
}
function hasError(result) {
    return result.status === Status.ERROR;
}
function useAsync(source, lazy, dependencyList, initialState) {
    if (lazy === void 0) { lazy = false; }
    var isCancelled = useRef(false);
    var _a = useState(0), rerunValue = _a[0], setRerunValue = _a[1];
    var lastRerun = useRef(rerunValue);
    var _b = useState(initialState || {
        status: lazy ? Status.INIT : Status.PENDING
    }), state = _b[0], setState = _b[1];
    useEffect(function () {
        var isRerun = lastRerun.current !== rerunValue;
        lastRerun.current = rerunValue;
        if (!lazy || (isRerun && ![Status.PENDING, Status.RELOADING].includes(state.status))) {
            if (state.status === Status.OK) {
                setState({ status: Status.RELOADING, data: state.data });
            }
            else {
                setState({ status: Status.PENDING });
            }
            source(isRerun).then(function (data) {
                if (!isCancelled.current) {
                    setState({ status: Status.OK, data: data });
                }
            }, function (error) {
                console.error(error);
                if (!isCancelled.current) {
                    setState({ status: Status.ERROR, error: error });
                }
            });
        }
        // Alle skal være med, men eslint greier ikke å analysere den
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencyList
        ? dependencyList.concat([rerunValue, lazy, isCancelled]) : [source, rerunValue, lazy, isCancelled]);
    useEffect(function () {
        return function () {
            isCancelled.current = true;
        };
    }, [isCancelled]);
    var rerun = useCallback(function () {
        setRerunValue(function (v) { return v + 1; });
    }, []);
    return useMemo(function () { return (__assign({}, state, { rerun: rerun })); }, [state, rerun]);
}

export default useAsync;
export { Status, isPending, hasData, hasError };
//# sourceMappingURL=use-async.es5.js.map
