{"ast":null,"code":"import useAsync__default, { Status } from '@nutgaard/use-async';\nexport * from '@nutgaard/use-async';\nimport { useCallback, useMemo, useState } from 'react';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar FetchCache =\n/** @class */\nfunction () {\n  function FetchCache() {\n    this.cache = {};\n    this.resolvedCache = {};\n  }\n\n  FetchCache.prototype.fetch = function (key, url, init) {\n    var _this = this;\n\n    if (this.hasKey(key)) {\n      return this.get(key).then(function (resp) {\n        return resp.clone();\n      });\n    }\n\n    var result = fetch(url, init);\n    this.put(key, result);\n    result.then(function (resp) {\n      if (!resp.ok) {\n        _this.remove(key);\n      }\n    }, function () {\n      _this.remove(key);\n    });\n    return result.then(function (resp) {\n      return resp.clone();\n    });\n  };\n\n  FetchCache.prototype.get = function (key) {\n    return this.cache[key];\n  };\n\n  FetchCache.prototype.getResolved = function (key) {\n    return this.resolvedCache[key];\n  };\n\n  FetchCache.prototype.putResolved = function (key, value) {\n    this.resolvedCache[key] = value;\n  };\n\n  FetchCache.prototype.put = function (key, value) {\n    this.cache[key] = value;\n  };\n\n  FetchCache.prototype.remove = function (key) {\n    delete this.cache[key];\n  };\n\n  FetchCache.prototype.clear = function () {\n    this.cache = {};\n    this.resolvedCache = {};\n  };\n\n  FetchCache.prototype.hasKey = function (key) {\n    // tslint:disable-next-line:strict-type-predicates\n    return this.cache[key] !== undefined;\n  };\n\n  FetchCache.prototype.hasKeyResolved = function (key) {\n    // tslint:disable-next-line:strict-type-predicates\n    return this.resolvedCache[key] !== undefined;\n  };\n\n  FetchCache.prototype.size = function () {\n    return Object.keys(this.cache).length;\n  };\n\n  return FetchCache;\n}();\n\nvar globaleFetchCache = new FetchCache();\n\nfunction createCacheKey(url, option) {\n  var method = option && option.method || 'GET';\n  var body = option && option.body && option.body.toString() || '';\n  var headers = option && option.headers && JSON.stringify(option.headers) || '';\n  return [url, method.toUpperCase(), body, headers].join('||');\n}\n\nfunction handleResponse(response, setStatusCode, cacheKey) {\n  return response.then(function (resp) {\n    setStatusCode(resp.status);\n\n    if (!resp.ok) {\n      throw new Error(resp.statusText);\n    }\n\n    if ([200, 201, 203, 206].includes(resp.status)) {\n      return resp.json();\n    }\n\n    return;\n  }).then(function (json) {\n    globaleFetchCache.putResolved(cacheKey, json);\n    return json;\n  });\n}\n\nfunction useFetch(url, option, config) {\n  if (config === void 0) {\n    config = {\n      lazy: false,\n      cacheKey: undefined\n    };\n  }\n\n  var _a = useState(-1),\n      statusCode = _a[0],\n      setStatusCode = _a[1];\n\n  var defaultCacheKey = createCacheKey(url, option);\n  var cacheKey = config.cacheKey || defaultCacheKey;\n  var source = useCallback(function (isRerun) {\n    setStatusCode(-1);\n    var response = isRerun ? fetch(url, option) : globaleFetchCache.fetch(cacheKey, url, option);\n\n    if (isRerun) {\n      globaleFetchCache.put(cacheKey, response);\n    }\n\n    return handleResponse(response, setStatusCode, cacheKey);\n  }, [url, option, cacheKey]);\n  var initialConfig = globaleFetchCache.hasKeyResolved(cacheKey) ? {\n    status: Status.OK,\n    data: globaleFetchCache.getResolved(cacheKey)\n  } : undefined;\n  var asyncResult = useAsync__default(source, config.lazy, [source], initialConfig);\n  return useMemo(function () {\n    return __assign({}, asyncResult, {\n      statusCode: statusCode\n    });\n  }, [asyncResult, statusCode]);\n}\n\nexport default useFetch;\nexport { createCacheKey, globaleFetchCache as cache };","map":null,"metadata":{},"sourceType":"module"}